method = "lm",
trControl = train.control)
# Summarize the results
cat("part B model results:\n")
print(model_part_B)
cat("\n\n##################################################\n\n")
cat("part E model results:\n")
print(model_part_E)
set.seed(42)
library(caret)
train.control <- trainControl(method = "cv", number = 5)
# Train the model
model_part_B <- train(G1 ~ G2 + G3 + failures, data = data,
method = "lm",
trControl = train.control)
model_part_E <- train(G1 ~ sex + age + Fjob + Mjob + romantic + studytime + failures + G2 + G3,
data = data,
method = "lm",
trControl = train.control)
# Summarize the results
cat("part B model results:\n")
print(model_part_B)
cat("\n\n##################################################\n\n")
cat("part E model results:\n")
print(model_part_E)
set.seed(42)
library(caret)
train.control <- trainControl(method = "cv", number = 5)
# Train the models
model_part_B <- train(G1 ~ G2 + G3 + failures,
data = data,
method = "lm",
trControl = train.control)
model_part_E <- train(G1 ~ sex + age + Fjob + Mjob + romantic + studytime + failures + G2 + G3,
data = data,
method = "lm",
trControl = train.control)
# Summarize the results
cat("part B model results:\n")
print(model_part_B)
cat("\n\n##################################################\n\n")
cat("part E model results:\n")
print(model_part_E)
cv.lm(best_backward, k=5)
library(lmvar)
cv.lm(best_backward, k=5)
library(lmvar)
cv.lm(best_backward, k=5)
create_formula = function(response, vars) {
as.formula(paste(response, paste(vars, collapse=" + "), sep=" ~ "))
}
stepwise_selection = function(method) {
full.vars <- c("school","sex","age","Fjob","Mjob","goout","internet","romantic","studytime","failures","health","absences","G2","G3")
selected <- rep(0, length(full.vars))
max_total_parameter <- 0
for(i in seq(1, length(full.vars))) {
remaining.vars <- full.vars[selected == 0]
if(length(remaining.vars) == 0) {
break
}
max_step_parameter <- 0
max_step_var <- NULL
for(j in seq(1, length(remaining.vars))) {
if(method == "forward") {
temp.vars <- c(full.vars[selected == 1], remaining.vars[j])
}
else if(method == "backward") {
temp.vars <- setdiff(full.vars[selected == 0], remaining.vars[j])
}
formula <- create_formula("G1", temp.vars)
model.temp.summary <- summary(lm(formula, data=data))
if(model.temp.summary$adj.r.squared > max_step_parameter) {
max_step_var <- remaining.vars[j]
max_step_parameter <- model.temp.summary$adj.r.squared
}
}
selected[which(full.vars == max_step_var)] = 1
if(max_total_parameter < max_step_parameter) {
max_total_parameter = max_step_parameter
}
else {
break
}
}
if(method == "forward")
return(lm(create_formula("G1", full.vars[selected == 1]), data=data))
else if(method == "backward")
return(lm(create_formula("G1", full.vars[selected == 0]), data=data))
}
best_forward <- stepwise_selection(method="forward")
best_backward <- stepwise_selection(method="backward")
summary(best_forward)
summary(best_backward)
# 5.F
# linearity
plot(best_backward, 1)
# # Summarize the results
# cat("part B model results:\n")
# print(model_part_B)
# cat("\n\n##################################################\n\n")
# cat("part E model results:\n")
# print(model_part_E)
library(lmvar)
cv.lm(best_backward, k=5)
create_formula = function(response, vars) {
as.formula(paste(response, paste(vars, collapse=" + "), sep=" ~ "))
}
stepwise_selection = function(method) {
full.vars <- c("school","sex","age","Fjob","Mjob","goout","internet","romantic","studytime","failures","health","absences","G2","G3")
selected <- rep(0, length(full.vars))
max_total_parameter <- 0
for(i in seq(1, length(full.vars))) {
remaining.vars <- full.vars[selected == 0]
if(length(remaining.vars) == 0) {
break
}
max_step_parameter <- 0
max_step_var <- NULL
for(j in seq(1, length(remaining.vars))) {
if(method == "forward") {
temp.vars <- c(full.vars[selected == 1], remaining.vars[j])
}
else if(method == "backward") {
temp.vars <- setdiff(full.vars[selected == 0], remaining.vars[j])
}
formula <- create_formula("G1", temp.vars)
model.temp.summary <- summary(lm(formula, data=data, y=True))
if(model.temp.summary$adj.r.squared > max_step_parameter) {
max_step_var <- remaining.vars[j]
max_step_parameter <- model.temp.summary$adj.r.squared
}
}
selected[which(full.vars == max_step_var)] = 1
if(max_total_parameter < max_step_parameter) {
max_total_parameter = max_step_parameter
}
else {
break
}
}
if(method == "forward")
return(lm(create_formula("G1", full.vars[selected == 1]), data=data))
else if(method == "backward")
return(lm(create_formula("G1", full.vars[selected == 0]), data=data))
}
best_forward <- stepwise_selection(method="forward")
create_formula = function(response, vars) {
as.formula(paste(response, paste(vars, collapse=" + "), sep=" ~ "))
}
stepwise_selection = function(method) {
full.vars <- c("school","sex","age","Fjob","Mjob","goout","internet","romantic","studytime","failures","health","absences","G2","G3")
selected <- rep(0, length(full.vars))
max_total_parameter <- 0
for(i in seq(1, length(full.vars))) {
remaining.vars <- full.vars[selected == 0]
if(length(remaining.vars) == 0) {
break
}
max_step_parameter <- 0
max_step_var <- NULL
for(j in seq(1, length(remaining.vars))) {
if(method == "forward") {
temp.vars <- c(full.vars[selected == 1], remaining.vars[j])
}
else if(method == "backward") {
temp.vars <- setdiff(full.vars[selected == 0], remaining.vars[j])
}
formula <- create_formula("G1", temp.vars)
model.temp.summary <- summary(lm(formula, data=data, y=TRUE))
if(model.temp.summary$adj.r.squared > max_step_parameter) {
max_step_var <- remaining.vars[j]
max_step_parameter <- model.temp.summary$adj.r.squared
}
}
selected[which(full.vars == max_step_var)] = 1
if(max_total_parameter < max_step_parameter) {
max_total_parameter = max_step_parameter
}
else {
break
}
}
if(method == "forward")
return(lm(create_formula("G1", full.vars[selected == 1]), data=data))
else if(method == "backward")
return(lm(create_formula("G1", full.vars[selected == 0]), data=data))
}
best_forward <- stepwise_selection(method="forward")
best_backward <- stepwise_selection(method="backward")
summary(best_forward)
summary(best_backward)
# 5.F
# linearity
plot(best_backward, 1)
# nearly normal residuals
plot(best_backward, 2)
# # Summarize the results
# cat("part B model results:\n")
# print(model_part_B)
# cat("\n\n##################################################\n\n")
# cat("part E model results:\n")
# print(model_part_E)
library(lmvar)
cv.lm(best_backward, k=5)
best_backward <- stepwise_selection(method="backward")
create_formula = function(response, vars) {
as.formula(paste(response, paste(vars, collapse=" + "), sep=" ~ "))
}
stepwise_selection = function(method) {
full.vars <- c("school","sex","age","Fjob","Mjob","goout","internet","romantic","studytime","failures","health","absences","G2","G3")
selected <- rep(0, length(full.vars))
max_total_parameter <- 0
for(i in seq(1, length(full.vars))) {
remaining.vars <- full.vars[selected == 0]
if(length(remaining.vars) == 0) {
break
}
max_step_parameter <- 0
max_step_var <- NULL
for(j in seq(1, length(remaining.vars))) {
if(method == "forward") {
temp.vars <- c(full.vars[selected == 1], remaining.vars[j])
}
else if(method == "backward") {
temp.vars <- setdiff(full.vars[selected == 0], remaining.vars[j])
}
formula <- create_formula("G1", temp.vars)
model.temp.summary <- summary(lm(formula, data=data))
if(model.temp.summary$adj.r.squared > max_step_parameter) {
max_step_var <- remaining.vars[j]
max_step_parameter <- model.temp.summary$adj.r.squared
}
}
selected[which(full.vars == max_step_var)] = 1
if(max_total_parameter < max_step_parameter) {
max_total_parameter = max_step_parameter
}
else {
break
}
}
if(method == "forward")
return(lm(create_formula("G1", full.vars[selected == 1]), data=data, y=TRUE))
else if(method == "backward")
return(lm(create_formula("G1", full.vars[selected == 0]), data=data, y=TRUE))
}
best_forward <- stepwise_selection(method="forward")
best_backward <- stepwise_selection(method="backward")
summary(best_forward)
# # Summarize the results
# cat("part B model results:\n")
# print(model_part_B)
# cat("\n\n##################################################\n\n")
# cat("part E model results:\n")
# print(model_part_E)
library(lmvar)
cv.lm(best_backward, k=5)
create_formula = function(response, vars) {
as.formula(paste(response, paste(vars, collapse=" + "), sep=" ~ "))
}
stepwise_selection = function(method) {
full.vars <- c("school","sex","age","Fjob","Mjob","goout","internet","romantic","studytime","failures","health","absences","G2","G3")
selected <- rep(0, length(full.vars))
max_total_parameter <- 0
for(i in seq(1, length(full.vars))) {
remaining.vars <- full.vars[selected == 0]
if(length(remaining.vars) == 0) {
break
}
max_step_parameter <- 0
max_step_var <- NULL
for(j in seq(1, length(remaining.vars))) {
if(method == "forward") {
temp.vars <- c(full.vars[selected == 1], remaining.vars[j])
}
else if(method == "backward") {
temp.vars <- setdiff(full.vars[selected == 0], remaining.vars[j])
}
formula <- create_formula("G1", temp.vars)
model.temp.summary <- summary(lm(formula, data=data))
if(model.temp.summary$adj.r.squared > max_step_parameter) {
max_step_var <- remaining.vars[j]
max_step_parameter <- model.temp.summary$adj.r.squared
}
}
selected[which(full.vars == max_step_var)] = 1
if(max_total_parameter < max_step_parameter) {
max_total_parameter = max_step_parameter
}
else {
break
}
}
if(method == "forward")
return(lm(create_formula("G1", full.vars[selected == 1]), data=data, y=TRUE, x=TRUE))
else if(method == "backward")
return(lm(create_formula("G1", full.vars[selected == 0]), data=data, y=TRUE, x=TRUE))
}
best_forward <- stepwise_selection(method="forward")
best_backward <- stepwise_selection(method="backward")
# # Summarize the results
# cat("part B model results:\n")
# print(model_part_B)
# cat("\n\n##################################################\n\n")
# cat("part E model results:\n")
# print(model_part_E)
library(lmvar)
cv.lm(best_backward, k=5)
mlr <- lm(formula = G1 ~ G2 + G3 + failures, data, x=TRUE, y=TRUE)
summary(mlr)
cv.lm(mlr, k=5)
library(lmvar)
cv.lm(mlr, k=5)
cv.lm(best_backward, k=5)
source('E:/University/fall-2020/Spring 00/SI/project/Phase 2/codes.R')
setwd("E:/University/fall-2020/Spring 00/SI/project/Phase 2")
library(ggplot2)
library(corrplot)
library(dplyr)
library(lmvar)
library(Metrics)
data <- read.csv("StudentsPerformance.csv")
################################################################### 1
# 1.A
n <- nrow(data)
n1 <- length(data$Fjob)
n2 <- length(data$Mjob)
################################################################### 5
# 5.A
library(GGally)
library(Metrics)
library(GGally)
p1 <- ggpairs(data.frame(
"G1"=data$G1,
"age"=data$age,
"goout"=data$goout,
"studytime"=data$studytime,
"failures"= as.factor(data$failures)
))
p2 <- ggpairs(data.frame(
"G1"=data$G1,
"health"=data$health,
"absences"=data$absences,
"G2"=data$G2,
"G3"=data$G3))
show(p1)
show(p2)
cor(data$failures, data$G1)
# 5.B
mlr <- lm(formula = G1 ~ G2 + G3 + failures, data, x=TRUE, y=TRUE)
summary(mlr)
plot(mlr)
anova(mlr)
# 5.E
create_formula = function(response, vars) {
as.formula(paste(response, paste(vars, collapse=" + "), sep=" ~ "))
}
stepwise_selection = function(method) {
full.vars <- c("school","sex","age","Fjob","Mjob","goout","internet","romantic","studytime","failures","health","absences","G2","G3")
selected <- rep(0, length(full.vars))
max_total_parameter <- 0
for(i in seq(1, length(full.vars))) {
remaining.vars <- full.vars[selected == 0]
if(length(remaining.vars) == 0) {
break
}
max_step_parameter <- 0
max_step_var <- NULL
for(j in seq(1, length(remaining.vars))) {
if(method == "forward") {
temp.vars <- c(full.vars[selected == 1], remaining.vars[j])
}
else if(method == "backward") {
temp.vars <- setdiff(full.vars[selected == 0], remaining.vars[j])
}
formula <- create_formula("G1", temp.vars)
model.temp.summary <- summary(lm(formula, data=data))
if(model.temp.summary$adj.r.squared > max_step_parameter) {
max_step_var <- remaining.vars[j]
max_step_parameter <- model.temp.summary$adj.r.squared
}
}
selected[which(full.vars == max_step_var)] = 1
if(max_total_parameter < max_step_parameter) {
max_total_parameter = max_step_parameter
}
else {
break
}
}
if(method == "forward")
return(lm(create_formula("G1", full.vars[selected == 1]), data=data, y=TRUE, x=TRUE))
else if(method == "backward")
return(lm(create_formula("G1", full.vars[selected == 0]), data=data, y=TRUE, x=TRUE))
}
best_forward <- stepwise_selection(method="forward")
best_backward <- stepwise_selection(method="backward")
summary(best_forward)
summary(best_backward)
# 5.F
# linearity
plot(best_backward, 1)
# nearly normal residuals
plot(best_backward, 2)
# constant variability
plot(best_backward, 3)
# 5.G
cv.lm(mlr, k=5)
cv.lm(best_backward, k=5)
############################################################### 6
# 6.A
set.seed(42)
data["romanticYes"] = as.numeric(data["romantic"] == "yes")
train.size <- floor(2/3 * nrow(data))
train.ind <- sample(seq_len(nrow(data)), size = train.size)
train.data <- data[train.ind, ]
test.data <- data[-train.ind, ]
clf_part_A <- glm(formula = romanticYes ~ school + sex + age + goout + internet + studytime + failures + absences + G1,
data=train.data,
family=binomial)
summary(clf_part_A)
probFemale <- seq(0, 0.99, 0.01)
OR_RATIO = abs(summary(classifier)$coefficients[3])
cat("OR RATIO =", OR_RATIO)
getY <- function(x) {
return ((OR_RATIO*x/(1-x)) / (1 + (OR_RATIO*x/(1-x))))
}
probMale <- sapply(probFemale, getY)
plot(probMale, probFemale, type = "l", lty = 1,
main="odds ratio plot of Sex",
xlab = "P(Romantic | Male)",
ylab = "P(Romantic | Female)")
lines(seq(0, 1, 0.01), seq(0, 1, 0.01), col="green")
plot(probMale, probFemale, type = "l", lty = 1,
main="odds ratio plot of Sex",
xlab = "P(Romantic | Male)",
ylab = "P(Romantic | Female)")
probFemale <- seq(0, 0.99, 0.01)
OR_RATIO = abs(summary(classifier)$coefficients[3])
OR_RATIO = abs(summary(clf_part_A)$coefficients[3])
cat("OR RATIO =", OR_RATIO)
getY <- function(x) {
return ((OR_RATIO*x/(1-x)) / (1 + (OR_RATIO*x/(1-x))))
}
probMale <- sapply(probFemale, getY)
plot(probMale, probFemale, type = "l", lty = 1,
main="odds ratio plot of Sex",
xlab = "P(Romantic | Male)",
ylab = "P(Romantic | Female)")
lines(seq(0, 1, 0.01), seq(0, 1, 0.01), col="green")
# 6.C
library(plotROC)
library(ggplot2)
plot_roc = function(clf) {
train.data$prediction <- predict(clf, newdata=train.data)
roc_curve <- ggplot(train.data,
aes(m = prediction,
d = romanticYes)) +
geom_roc(n.cuts=20,
labels=F) +
theme_classic() +
geom_abline(slope=1, intercept = 0)
show(roc_curve + annotate("text", x = .75, y = .25 , label =
paste("Aear Under Curve =",
round(calc_auc(roc_curve)["AUC"], 3))))
test.data$prediction <- predict(clf, newdata=test.data)
roc_curve <- ggplot(test.data,
aes(m = prediction,
d = romanticYes)) +
geom_roc(n.cuts=20,
labels=F) +
theme_classic() +
geom_abline(slope=1, intercept = 0)
show(roc_curve + annotate("text", x = .75, y = .25 , label =
paste("Aear Under Curve =",
round(calc_auc(roc_curve)["AUC"], 3))))
}
plot_roc(clf_part_A)
clf_part_E <- glm(formula = romanticYes ~ age + absences + studytime + internet,
data=train.data,
family=binomial)
summary(clf_part_E)
plot_roc(clf_part_E)
thresholds = seq(0, 1, 0.1)
U <- c()
for(i in seq(1, length(thresholds))) {
predict_probs <- predict(clf_part_E, newdata=data)
t <- confusionMatrix(data = as.factor(as.numeric(predict_probs > thresholds[i])),
reference=as.factor(data$romanticYes))$table
TP = t[4]
TN = t[1]
FP = t[2]
FN = t[3]
U = c(U, TP + TN -20*FP - 10*FN)
}
plot(thresholds, U, type='l')
max_th = thresholds[which(U == max(U))]
cat("Maximum Unitility happens when threshold =", max_th)
data$academic_probation = as.numeric((data$G1 + data$G2 + data$G3) < 25)
aca_prob_model <- glm(formula = academic_probation ~ school+sex+
age+Fjob+Mjob+goout+internet+romantic+
studytime+failures+health++absences,
data=data,
family=binomial)
summary(aca_prob_model)
data$academic_probation = as.numeric((data$G1 + data$G2 + data$G3) < 25)
aca_prob_model <- glm(formula = academic_probation ~ school+sex+
age+Fjob+Mjob+goout+internet+romantic+
studytime+failures+health++absences,
data=data,
family=binomial)
summary(aca_prob_model)
